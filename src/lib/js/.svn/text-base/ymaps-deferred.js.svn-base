YUI.add('myc-ymaps', function(Y){

var OVERLAY_TYPE = {
        MARKER: "markers",
        ROUTE : "routes",
        CONTROL: "controls"
    };
    // todo - extend these classes instead of overriding. that way you can set default options as well
    var Map = function(){
        Map.superclass.constructor.apply(this, arguments);
    };

    Map.NAME = Y.YMaps.Map.NAME;
    Y.extend(Map, Y.YMaps.Map,{
        render: function(callback){
            callback = callback || function(){};
            if (!this.get('_isRenderComplete')) {
                this.onceAfter('renderComplete', callback);
                // to do - check if this is required
                if (!this._rendering) {
                    this._rendering = true;
                    Y.YMaps.Map.prototype.render.apply(this, arguments);
                    this.customEvents();
                    this.updateZoomControls();
                }
            } else {
                callback();
            }
        },
        /**
        * @method getValidType
        * @return {object}
        */
        getValidType : function(v){
            return this.get('validTypes')[Y.Array.indexOf(['m','h','trf','w','s'], v)];
        },
        /**
        * @method updateZoomControls
        * @return {boolean}
        */
        updateZoomControls : function(){
            var zoomIn = 'Zoom In',
                zoomOut = 'Zoom Out';

            if (this.get('zoomLevel') === Y.myc.config('ymaps.maxZoom')) {
                zoomIn = 'Maximum zoom level reached';
            }

            if (this.get('zoomLevel') === Y.myc.config('ymaps.minZoom')) {
                zoomOut = 'Minimum zoom level reached';
            }

            if (this.get('boundingBox').one('.ymap-control-zoomcontainer')) {
                this.get('boundingBox').one('.ymap-control-zoominbutton').set('title',zoomIn);
                this.get('boundingBox').one('.ymap-control-zoomoutbutton').set('title',zoomOut);
                this.get('boundingBox').one('.yui3-slider-thumb-image').set('title','Drag to zoom');
            }
            if (this.get('boundingBox').one('.yui3-controlsmallsimplezoom')) {
                this.get('boundingBox').one('.yui3-controlsmallsimplezoom').one('.in').set('title',zoomIn);
                this.get('boundingBox').one('.yui3-controlsmallsimplezoom').one('.out').set('title',zoomOut);
            }
        },
        /**
        * @method checkCenterChangeByPercentage
        * @return {boolean}
        */
        checkCenterChangeByPercentage: function(previousCenter,percentage){
            var mapCenter = this.get('center');

            if (mapCenter !== previousCenter) {
                var delta = mapCenter.getDeltaXy(previousCenter , this.get('zoomLevel')),
                    requeryX = Math.abs(delta.x) > (this.get('width') * (percentage || Y.myc.config('ymaps.percentBeforeRequery')) / 100);
                    requeryY = Math.abs(delta.y) > (this.get('height') * (percentage || Y.myc.config('ymaps.percentBeforeRequery')) / 100);

                if (requeryX || requeryY) {
                    return {
                        'lat' : mapCenter.get('lat'),
                        'lon' : mapCenter.get('lon')
                    };
                } else {
                    return null;
                }
            } else {
                return null;
            }
        },
        /**
        * @method updatePan
        * @return {void}
        */
        updatePan: function(e){
            var activeButton = e.currentTarget,
                parentDiv = activeButton.get('parentNode');
            if (e.type === "mouseenter") {
                if (activeButton.hasClass('up')) {
                    activeButton.set('title','Pan up');
                    parentDiv.addClass('up-hover');
                } else if (activeButton.hasClass('down')) {
                    activeButton.set('title','Pan down');
                    parentDiv.addClass('down-hover');
                } else if (activeButton.hasClass('left')) {
                    activeButton.set('title','Pan left');
                    parentDiv.addClass('left-hover');
                } else if (activeButton.hasClass('right')) {
                    activeButton.set('title','Pan right');
                    parentDiv.addClass('right-hover');
                }
            } else {
                if (activeButton.hasClass('up')){
                    parentDiv.removeClass('up-hover');
                } else if (activeButton.hasClass('down')) {
                    parentDiv.removeClass('down-hover');
                } else if (activeButton.hasClass('left')) {
                    parentDiv.removeClass('left-hover');
                } else if (activeButton.hasClass('right')) {
                    parentDiv.removeClass('right-hover');
                }
            }
        },
        /**
        * @method updateTraffic
        * @return {void}
        */
        updateTraffic: function(e){
            var target = e.currentTarget;

            if (target.hasClass('css3-button-clicked')) {
                target.set('title','Traffic Conditions is active');
            } else {
                target.set('title','Show Traffic Conditions');
            }
        },
        /**
        * @method updateMapType
        * @return {void}
        */
        updateMapType: function(e){
            e.currentTarget.set('title',e.currentTarget.one('.maptype-label').getContent()+' is active');
        },
        // set up our map to throw some custom events
        customEvents: function(){
            var t = this;

            t.get('boundingBox').delegate({
                mouseenter: function(e){t.updatePan(e);},
                mouseleave: function(e){t.updatePan(e);}
            },'.yui3-controlpan-content button');

            t.get('boundingBox').delegate({
                mouseenter: function(e){t.updateTraffic(e);},
                mouseleave: function(e){t.updateTraffic(e);}
            },'.yui3-controltraffic-content a');

            t.get('boundingBox').delegate({
                mouseenter: function(e){t.updateMapType(e);},
                mouseleave: function(e){t.updateMapType(e);}
            },'.yui3-controlmaptype-content .header');

            t.after('zoomLevelChange',function(e){
               t.updateZoomControls() ;
            });

            // todo - make sure this is fired from the same map instance as this
            Y.on({
                'myc:map:mouse:scroll:zoom' : function(e){
                    t.fire('user:zoom', e);
                },
                'myc:map:zoom:out:click' : function(e){
                    t.fire('user:zoom', e);
                },
                'myc:map:zoom:in:click' : function(e){
                    t.fire('user:zoom', e);
                },
                'myc:map:zoom:slide' : function(e){
                    t.fire('user:zoom', e);
                }
            });
        },
        setControls: function(config){
            var pan,
                zoom,
                mapType,
                scale,
                mouse,
                keyboard,
                traffic,
                zoomCssTop = '59px',
                mapTypeControlTop = '22px',
                mapTypeControlRight = '62px',
                t = this;

            if (config.isPrintPage) {
                zoomCssTop = '6px';
                mapTypeControlTop = '12px';
                mapTypeControlRight = '50px';
            }

            if (config.pan) {
                pan = new Y.YMaps.ControlPan({ map: this });
                pan.get('boundingBox').setStyles({
                    top: '10px',
                    right: '6px'
                });
                this.draw(pan);
            }
            if (config.zoom) {
                if(config.multiMapType && config.multiMapType !== 'singleFull') {
                    zoom = new Y.YMaps.ControlSmallSimpleZoom({ map: this });
                    zoom.get('boundingBox').setStyles({
                        top: zoomCssTop,
                        right: '6px'
                    });
                    this.draw(zoom);
                }else{
                    zoom = new Y.YMaps.ControlZoom({ map: this });
                    zoom.get('boundingBox').setStyles({
                        top: zoomCssTop,
                        right: '6px'
                    });
                    this.draw(zoom);
                }
            }

            if (config.scale) {
                scale = new Y.YMaps.ControlScale({ map: this });
                if (Y.one('#footer')) {
                    scale.get('boundingBox').setStyles({
                        'right': 10 + Y.one('#footer').get('offsetWidth'),
                        'padding': '0 0 5px 0'
                    });
                }
                this.draw(scale);
            }

            if (config.mapTypeControl) {
                mapType = new Y.YMaps.ControlMapType({ map: this });
                this.draw(mapType);
                mapType.get('boundingBox').get('parentNode').setStyles({
                    top: mapTypeControlTop,
                    right: mapTypeControlRight
                });
            }

            if (config.trafficControl) {
                traffic = new Y.YMaps.ControlTraffic({ map: this });
                this.draw(traffic);
            }

            if (config.mouse) {
                mouse = new Y.YMaps.ControlMouse({ map: this });
                this.draw(mouse);
            }

            if (config.keyboard) {
                keyboard = new Y.YMaps.ControlKeyboard({ map: this });
                this.draw(keyboard);
            }
        }
    },{
        ATTRS: {
            bb: {
                getter: function(value){
                    var o = {},
                        center = this.get('center'),
                        pxBoundingBox  = this.get('projection').getVisibleBoundingBox({
                            lat    : center.get('lat'),
                            lon    : center.get('lon'),
                            height : this.get('height'),
                            width  : this.get('width')
                        });
                    // o.tl = [pxBoundingBox.topLeft.lat, pxBoundingBox.topLeft.lon];
                    // o.br = [pxBoundingBox.bottomRight.lat, pxBoundingBox.bottomRight.lon];

                    var deltaLat = pxBoundingBox.topLeft.lat - center.get('lat'),
                        deltaLon = pxBoundingBox.bottomRight.lon - center.get('lon');
                    o.tl = [(center.get('lat') + deltaLat), (center.get('lon') - deltaLon)];
                    o.br = [(center.get('lat') - deltaLat), (center.get('lon') + deltaLon)];

                    return [o.tl.join(','), o.br.join(',')].join(',');
                }
            },
            // used specific for flickr since flickr bbox defination is as below
            // The 4 values represent the bottom-left corner of the box and the
            // top-right corner, minimum_longitude, minimum_latitude, maximum_longitude,
            // maximum_latitude.
            flickrBB : {
                getter: function(value){
                    var o = {},
                        center = this.get('center'),
                        pxBoundingBox  = this.get('projection').getVisibleBoundingBox({
                            lat    : center.get('lat'),
                            lon    : center.get('lon'),
                            height : this.get('height'),
                            width  : this.get('width')
                        });

                    o.bl = [pxBoundingBox.bottomLeft.lon, pxBoundingBox.bottomLeft.lat];
                    o.tr = [pxBoundingBox.topRight.lon, pxBoundingBox.topRight.lat];
                    return [o.bl.join(','), o.tr.join(',')].join(',');
                }
            }
        }
    });

    Y.namespace('myc');
    Y.myc.YMap = Map;

    var MapDeferred = function(config){
        MapDeferred.superclass.constructor.apply(this, arguments);
        this.host = config.host;
    };

    MapDeferred.NS = 'deferred';

    Y.extend(MapDeferred, Y.Promise, {
        render:function(){
            if(this.host.deferred === this){
                this.resolve();
            }
            var deferred = this.defer(function(promise){
                this.host.render(function(){
                    promise.resolve();
                });
            });
            return deferred;
        }
    });

    Y.namespace('myc.Plugin').MapDeferred = MapDeferred;


    // other mods. nice convenient place to put these
    
    // this one's for a bugfix, hence editing the prototype directly
    Y.YMaps.GeoLocation.prototype.getDeltaXy = function(pointB, zoomLevel){
        var pointA = {
                lat: this.get('lat'),
                lon: this.get('lon')
            },
            delta;

        // create projection
        var projection = new Y.YMaps.Projection({
            zoomLevel: zoomLevel
        }),
        pointA_pxy,
        pointB_pxy;

        // convert current point's XY
        pointA_pxy = projection.latLonToPxy({
            Lat: pointA.lat,
            Lon: pointA.lon
        });

        // convert pointB's XY
        pointB_pxy = projection.latLonToPxy({
            Lat: pointB.get('lat'),
            Lon: pointB.get('lon')
        });

        delta = {
            x: pointB_pxy.x - pointA_pxy.x,
            y: pointB_pxy.y - pointA_pxy.y
        };

        return delta;

    };

    // this one's to leverage myc-jsonp
    Y.YMaps.Util.request = function(url, options, customCallback) {
        customCallback = customCallback || {};
        var appid = Y.YMaps.get('appid'),
            locale = Y.YMaps.get('locale');

        options += '&appid=' + appid;
        options += '&locale=' + locale;

        // Y.log('[util] request(): firing jsonp request: ' + url + options);
        options = encodeURI(options);
        // Bug 4760628, replace # with encoded string. Can't call encodeURIComponent on all inputs
        // because we have characters in the string that we don't want to encode.
        options = options.replace(/#/g, "%23");
        // // fire the request

        var success = Y.Lang.isFunction(customCallback)? customCallback : customCallback.success || function(){}, timeout, failure;
        if(!Y.Lang.isFunction(customCallback)){
            timeout = customCallback.timeout || function(){};
            failure = customCallback.failure || function(){};
        }

        // massaging responses, so as to match ymaps expected format
        Y.myc.jsonp(url+options, {on:{
            success: function(data){
                success({data:data});
            },
            error: function(err){
                error && error({data:{Error:err}});
            },
            timeout: function(tm){
                timeout && timeout({data:tm});
            }
        }});
    };
    /*
    * PROTOTYPE YMAPS OVERLAY _drawRoute METHOD TO AVOID ROUTE ZOOM
    * TODO : REMOVE ONCE YMAPS ADDS SUPPORT
    */
    Y.YMaps.OverlayManager.prototype._drawRoute = function(route, conf){
        Y.log("[Overlay Manager] _drawRoute");

        //if route already exists in the registry, just redraw it
        var routeFound = this._getFromRegistryById(route.get('id'), OVERLAY_TYPE.ROUTE);
        if(routeFound){
            route.redraw();
        }
        else{
            // COMMENTED BY PAVAN RATNAKAR TO AVOID ZOOM FOR ROUTE DRAW
            //need to set map zoom level first, since route use that zoom level
            //projection to draw
            // if (route.get('zoomLevel') !== this.get('map').get('zoomLevel')) {
            //     //change map zoom level on first route request to fit the route
            //     this.get('map').set('zoomLevel', route.get('zoomLevel'));
            // }

            this._addToRegistry(route, OVERLAY_TYPE.ROUTE);
            route.set('map', this.get('map'));

            //if there is any custom config, set the custom config
            route.updateStyle(conf);

            route.render(this.getOverlayBody(OVERLAY_TYPE.ROUTE));
            //hook up this event to set route busy flag during route request
            this.after("route:routeUpdateEnded", Y.bind(function() {
                this.set('routeBusy', false);}, this));
            this.after("route:routeUpdateStart", Y.bind(function() {
                this.set('routeBusy', true);}, this));
        }
    };

    var _oMS = Y.YMaps.ControlMouse.prototype._onMouseScroll;
    Y.YMaps.ControlMouse.prototype._onMouseScroll = function(e){
        _oMS.apply(this, arguments);
        Y.fire('myc:map:mouse:scroll:zoom',e);
    };

    var _oDC = Y.YMaps.ControlMouse.prototype._onDblClick;
    Y.YMaps.ControlMouse.prototype._onDblClick = function(e){
        var target = Y.one(e.target);
        var ancestor = target.ancestor();

        var cond = ancestor && (ancestor.hasClass('ymap-tilebody') || ancestor.hasClass('ymap-trafficbody'));
        cond = target.hasClass('ymap-trafficbody') || cond;

        if(cond){
            _oDC.apply(this, arguments);
            this.get('_map').fire('user:zoom');
        }
    };

    var _oZOC = Y.YMaps.ControlZoomButton.prototype._onZoomOutClick;
    Y.YMaps.ControlZoomButton.prototype._onZoomOutClick = function(e){
        _oZOC.apply(this, arguments);
        Y.fire('myc:map:zoom:out:click', e);
    };

    var _oZIC = Y.YMaps.ControlZoomButton.prototype._onZoomInClick;
    Y.YMaps.ControlZoomButton.prototype._onZoomInClick = function(e){
        _oZIC.apply(this, arguments);
        Y.fire('myc:map:zoom:in:click', e);
    };

    var _rUI = Y.YMaps.ControlZoom.prototype.renderUI;
    Y.YMaps.ControlZoom.prototype.renderUI = function(){
        var t = this;
        _rUI.apply(this, arguments);
        this.get('_slider').on('slideEnd', function(e){
            Y.fire('myc:map:zoom:slide', e);
        });
    };
}, '@VERSION@', {requires:['ymaps', 'myc-config', 'myc-deferred', 'plugin','myc-jsonp', 'myc-ymaps-route-ui']});