YUI.add('myc-util',function(Y){
    "use strict";

    // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/Reduce#Browser_compatibility
    if (!Array.prototype.reduce) {
      Array.prototype.reduce = function reduce(accumulator){
        if (this===null || this===undefined) throw new TypeError("Object is null or undefined");
        var i = 0, l = this.length >> 0, curr;

        if(typeof accumulator !== "function") // ES5 : "If IsCallable(callbackfn) is false, throw a TypeError exception."
          throw new TypeError("First argument is not callable");

        if(arguments.length < 2) {
          if (l === 0) throw new TypeError("Array length is 0 and no second argument");
          curr = this[0];
          i = 1; // start accumulating at the second element
        }
        else
          curr = arguments[1];

        while (i < l) {
          if(i in this) curr = accumulator.call(undefined, curr, this[i], i, this);
          ++i;
        }

        return curr;
      };
    }

    // some modding to the environment
    var Util = {
        debounce : function(func, wait, immediate){
            var timeout;
            return function () {
                var context = this,
                    args = arguments;
                var later = function () {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow){
                    func.apply(context, args);
                }
            };
        },
        atPath: function(o, path){
            var pointer = o;
            var failed = false;
            Y.each(path.split('.'), function(p){
                if(Y.Lang.isValue(pointer[p]) && !failed)
                    pointer = pointer[p];
                else
                    failed = true;
            });
            return failed? null : pointer;
        },
        setAtPath: function(o, key, val){
            if (typeof key === 'string') {
                var path = key.split('.');
                var node = o || {};
                Y.times(path.length - 1 , function(i){
                    var _node = node[path[i]];
                    if(!Y.Lang.isValue(_node)){
                        _node = node[path[i]] = {};
                    }
                    node = _node;
                });
                node[path[path.length-1]] = val;
            }
            else{
                //setting object hash by deepcopy
                var t = this;
                Y.each(this.paths(key), function(p, i){
                    t.setAtPath(o, p.key, p.value);
                });
            }
        },
        paths: function(o){
            // enumerate json paths to all leaves
            var paths = [];
            Y.each(Y.Object.keys(o), function(k){
                var _t = typeof o[k];
                if ((!Y.Lang.isValue(o[k])) || _t==='string' || _t==='number' || Y.Lang.isArray(o[k])  || _t==='boolean') {
                    paths.push({
                        key:k,
                        value: o[k]
                    });
                    return;
                } else {
                    var childPaths = Y.myc.util.paths(o[k]);
                    paths = paths.concat(Y.times(childPaths.length, function(i){
                        return({
                            key:k + '.' + childPaths[i].key,
                            value: childPaths[i].value
                        });
                    }));
                }
            });
            return paths;
        },
        assets: function(path){
            Y.myc._assets = Y.myc._assets || {};


            // todo - cleanup this final url generation logic to handle cdns, etc.
            // separate into module and path
            path = path.split('/');
            var module = path[0];
            path.splice(0,1);
            path = path.join('/');
            // for now just use base + path
            if(YUI_config.groups.myc.combine===true){
                // harcoding cdnbase for now, need a cleaner way to do this (though I doubt it'll change any time soon)
                // [bug 5892107] as we are now removing the hash file and depending on the version number for cache busting
                //return 'http://l.yimg.com/' + YUI_config.groups.myc.root + module + '/' + (((Y.myc._assets[module]||{})[path]) || path);
                return 'http://l.yimg.com/' + YUI_config.groups.myc.root + module + '/' + path;
                // return (YUI_config.groups.myc.base + module + '/' + (((Y.myc._assets[module]||{})[path]) || path));
            }
            return YUI_config.groups.myc.base + module + '/' + path;
        },
        /**
        * @method addActiveBorder
        * @return {void}
        */
        addActiveBorder : function(node){
            node.
                addClass('active').
                addClass('border');
            if (node.previous()) {
                node.
                    previous().addClass('no-right-border');
            }
            if (node.next()) {
                node.
                    next().addClass('no-left-border');
            }
        },
        /**
        * @method removeActiveBorder
        * @return {void}
        */
        removeActiveBorder : function(node){
            node.
                removeClass('active').
                removeClass('border');
            if (node.previous()) {
                node.
                    previous().removeClass('no-right-border');
            }
            if (node.next()) {
                node.
                    next().removeClass('no-left-border');
            }
        },
        /**
        * calculate bounding box for an array of locations
        * @method setBoundingBox
        * @param any number of locations, followed by an optional percent padding (numerical value)
        * @return {void}
        */
        bb: function(){
            var locations = Y.Array(arguments),
                minLat,
                minLon,
                maxLat,
                maxLon,
                padding = 0;

            // Check to see if the last argument is the padding
            if (Y.Lang.isNumber(locations[locations.length - 1])) {
                padding = parseInt(locations[locations.length - 1], 10) / 100; // converting it to percent
                locations.splice(locations.length - 1, 1); // removing the padding from the array of locations
            }
            locations = Y.flatten(locations);

            Y.each(locations,function(location, index){
                if (index === 0) {
                    minLat = maxLat = location.getLatitude();
                    minLon = maxLon = location.getLongitude();
                } else {
                    minLat = Math.min(minLat,location.getLatitude());
                    minLon = Math.min(minLon,location.getLongitude());
                    maxLat = Math.max(maxLat,location.getLatitude());
                    maxLon = Math.max(maxLon,location.getLongitude());
                }
            });

            var deltaLat = (maxLat - minLat) * padding,
                deltaLon = (maxLon - minLon) * padding;

            return({
                tl: new Y.YMaps.GeoLocation({
                    lat : minLat - deltaLat,
                    lon : minLon - deltaLon
                }),
                br: new Y.YMaps.GeoLocation({
                    lat : maxLat + deltaLat,
                    lon : maxLon + deltaLon
                })
            });
        },
        /**
        * calculate the adaptive bounding box for business with the location at the center
        * @method adaptiveBb
        * @param {object} businesses (Array), location (Object)
        * @return {void}
        */
        adaptiveBb: function(businesses, location){
            if (!location) {
                return this.bb(businesses);
            }

            var maxDeltaLat,
                maxDeltaLon;

            Y.each(businesses,function(business, index){
                if (index === 0) {
                    maxDeltaLat = Math.abs(location.getLatitude() - business.getLatitude());
                    maxDeltaLon = Math.abs(location.getLongitude() - business.getLongitude());
                } else {
                    maxDeltaLat = Math.max(maxDeltaLat, Math.abs(location.getLatitude() - business.getLatitude()));
                    maxDeltaLon = Math.max(maxDeltaLon, Math.abs(location.getLongitude() - business.getLongitude()));
                }
            });

            return({
                tl: new Y.YMaps.GeoLocation({
                    lat : location.getLatitude() - maxDeltaLat,
                    lon : location.getLongitude() - maxDeltaLon
                }),
                br: new Y.YMaps.GeoLocation({
                    lat : location.getLatitude() + maxDeltaLat,
                    lon : location.getLongitude() + maxDeltaLon
                })
            });
        },
        /**
        * Accessibility best focus
        * @method bestFocus
        * @param {object} data
        * @return {void}
        */
        bestFocus:function(data){
            var focus = false;
            data.container.all(data.type).some(function(node,index) {
                if (!node.get('value')) {
                    if (!Y.one('#' + node.get('id') + ':focus')) {
                        Y.later(10, {}, function(){
                            node.focus();
                        });
                        focus = true;
                        return true;
                    }
                }
            });
            if (!focus) {
                data.container.all(data.type).item(0).focus();
            }
        },
        /**
        * @method showFader
        * @return {void}
        */
        showFader : function(){
            Y.one('#myc-fader-container').setStyles({
                display : 'block',
                visibility : 'visible',
                height : Y.one('body').get('offsetHeight'),
                width :  Y.one('body').get('offsetWidth')
            });
            Y.one('#myc-fader-overlay').addClass('anim');
        },
        /**
        * @method hideFader
        * @return {void}
        */
        hideFader : function(){
            Y.one('#myc-fader-overlay').removeClass('anim');
            // [bug 5904046]
            Y.one('#myc-fader-container').hide();
        },
        /**
        * @method resizeFader
        * @return {void}
        */
        resizeFader : function(){
            Y.one('#myc-fader-container').setStyles({
                height : Y.one('body').get('offsetHeight'),
                width :  Y.one('body').get('offsetWidth')
            });
        },
        /**
        * @method tinifyURL
        * @return {void}
        */
        tinifyURL : function(url, callback){
            Y.YQL('INSERT INTO yahoo.y.ahoo.it (url) values ("'+url+'")', function(r) {
                callback && callback (Y.myc.util.atPath(r, 'query.results.url'));
            });
        },
        /**
        * @method checkNodeHidden
        * @return {void}
        */
        checkNodeHidden : function(node){
            if ((node.get('offsetWidth') === 0 && node.get('offsetHeight') === 0) || node.getStyle('display') === 'none') {
                return true;
            } else {
                return false;
            }
        },
        urlsafe: function(str){
            // todo - this should become stronger. decent for now, especially for booleans.
            if(str===true){
                return '1';
            }
            if (str===false){
                return '0';
            }
            return str + '';
        },
        cleanQuery: function(_q){
            var q = _q.charAt(0);
            for (var i = 1, j = _q.length; i < j; i++) {
                if (!(_q.charAt(i) === ' ' && _q.charAt(i - 1) === ' ')) {
                    q += _q.charAt(i);
                }
            }
            return q;
        },
        /**
        * @method checkTypeOfURL
        * @return {boolean}
        */
        checkTypeOfURL: function(type){
            // first level : either direction / business / place / legacy
            var qo = Y.getLocation().href.split('?')[1] || Y.getLocation().href.split('#')[1];
            if (qo) {
                qo = Y.QueryString.parse(qo);
                if (type === 'd_b_p_bb') {
                    if (qo.bb || qo.addr || qo.ll || qo.n || qo.naddr || qo.nllr || qo.b || qo.o || qo.addr || qo.oll || qo.d || qo.daddr || qo.dll || (qo.lat && qo.lon) || qo.tt || qo.q || qo.q1 || qo.q2) {
                        return true;
                    }
                } else if (type === 'd_b_p') {
                    if (qo.addr || qo.ll || qo.n || qo.naddr || qo.nllr || qo.b || qo.o || qo.addr || qo.oll || qo.d || qo.daddr || qo.dll || (qo.lat && qo.lon) || qo.tt || qo.q || qo.q1 || qo.q2) {
                        return true;
                    }
                }
            }
            return false;
        },
        /**
        * @method getURLQueryParam
        * @return {string}
        */
        getURLQueryParam: function(type){
            var qo = Y.getLocation().href.split('?')[1] || Y.getLocation().href.split('#')[1];
            if (qo) {
                qo = Y.QueryString.parse(qo);
                if (eval('qo.'+type)) {
                    return eval('qo.'+type);
                }
            }
            return false;
        },
        /**
        * @method cleanArray
        * @return {array}
        */
        cleanArray: function(a){
            return Y.Array.filter(a,function(e){
                return e;
            });
        },
        setPageTitle : function(str){
            document.title = str;
        },
        visible: function(el){
            var ele = Y.one(el);
            if (ele.getStyle('visibility')==='none' || ele.getStyle('display')==='none') {
                return true;
            }
            else{
                return false;
            }
        },
        computeBestZoomWithPadding: function(options){

            var tl = options.tl,
                br = options.br,
                height = options.height,
                width = options.width,
                padding = options.padding;

            var i,
                pxBR,
                pxTL,
                pxHeight,
                pxWidth;

            for(i = Y.YMaps.Projection.maxZoom;i >= Y.YMaps.Projection.minZoom;i--){
                pxBR = Y.YMaps.Projection.latLonToPxy({
                    "Lat": br.get("lat"),
                    "Lon": br.get("lon")
                }, i);
                pxTL = Y.YMaps.Projection.latLonToPxy({
                    "Lat": tl.get("lat"),
                    "Lon": tl.get("lon")
                }, i);

                // convert padding to the pixel value applied to total
                // height and width
                pxHeight = Math.abs(pxBR.y - pxTL.y) + (padding / 50);
                pxWidth = Math.abs(pxBR.x - pxTL.x) + (padding / 50);

                // @sunilpai - using height and width instead of offsetheight/offsetwidth.
                if (pxHeight <= height && pxWidth <= width) {
                    return i;
                }
            }

            // fallback, zoom all the way out
            return Y.YMaps.Projection.minZoom;
        },
        /**
        * @method namespaceExists
        * @return {function}
        */
        namespaceExists : function (namespace) {
            var tokens = namespace.split('.');
            return tokens.reduce(function(prev, curr) {
                return (typeof prev == "undefined") ? prev : prev[curr];
            }, window);
        },
        /**
        * @method checkIfLatLon
        * @return {boolean}
        */
        checkIfLatLon : function(q) {
            // http://stackoverflow.com/questions/3518504/regular-expression-for-matching-latitude-longitude-coordinates
            if (q.match(/^([-+]?\d{1,2}([.]\d+)?),\s*([-+]?\d{1,3}([.]\d+)?)$/)) {
                return true;
            }
            return false;
        },
        getCenterForBBox: function(bbox){
            var lat = (bbox.tl.get('lat')+bbox.br.get('lat')) / 2;
            var lon = (bbox.tl.get('lon')+bbox.br.get('lon')) / 2;
            return (new Y.YMaps.GeoLocation({lat: lat, lon: lon}));
        },
        sanitize: function(str){
            return Y.Escape.html(str);
        },
        _destructor: function(eventListeners){
            if (eventListeners && eventListeners.length > 0) {
                Y.Array.each(eventListeners,function(e,i){
                    e.detach();
                    e = null;
                });
                eventListeners = [];
            }
            return [];
        }
    };

    Y.namespace('myc');
    Y.myc.util = Util;


},'@VERSION@',{requires:['oop', 'node', 'transition', 'escape']});
