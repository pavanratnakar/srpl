YUI.add('myc-app-router', function(Y){
    "use strict";

    var defaults = {
        // environment
        'cache':    1,      // cache on. can be 0, or 'flush'
        'router':   1,      // use router to change urls. todo.
        'intl':     'en-US',

        // app level
        'lat':      null,   // map center lat (For Backward Compatibility 5box)
        'lon':      null,   // map center lon (For Backward Compatibility 5box)
        'q':        null,   // text in onebox query
        'c':        null,   // map center (don't forget offset)             *print
        'z':        null,   // zoom level                                   *print
        't':        'h',    // map type - m/s/h                             *print
        'bb':       null,   // boundingbox - lat,lon,lat,lon  (tl,br)       *print
        'trf':      null,   // show traffic                                 *print
        'f':        null,   // show flickr

        // per action
        // /place/*params
        'addr':     null,
        'll':       null,   // lat,lon

        // /businesses/*params
        'n':        null,
        'naddr':    null,
        'nllr':     null,
        'nid':      null,
        'hn':       null, // hide Location Name
        'sm':       null, // show Location Marker
        'bt':       null, // business title (use for the onebox query as '<title> near <location>')
        'bid':      null, // With the change required to support only showing a particular business, we will be getting the businessId from the local BPP redirect

        'b':        null,   // business part. eg, 'pizza'
        'p':        null,
        'conf':     null,

        // /directions/*params
        'dt':       null,   // directions type - pedestrian, car, etc

        'o':        null,
        'oaddr':    null,
        'oll':      null,

        'd':        null,
        'daddr':    null,
        'dll':      null,

        // only one of the following
        'w':        null,   // array
        'waddr':    null,   // array
        'wll':      null,    // array,

        'units': null,
        'fwy': null,
        'tolls': null

        // /search/:params
        // convenience for a nicer url. basically use q, and redirect.
    };

    var Router = function(config){
        var t = this;

        t.host = config.host;
        t.routing = false;
        t.routingCount = 0;
        Router.superclass.constructor.apply(this, arguments);
        t.on({
            'end' : function(){
                Y.log('Router : End');
                t.clear();
            }
        });
    };
    Router.NAME= 'appRouter';
    Router.NS =  'router';

    // easy route callback factory
    var __ = function(f){
        return(function(req, res, next){
            this[f](req, res, next);
        });
    };

    Router.ATTRS = {
        silent: {
            value:true  // use as a state switch to execute action handler or not
        },
        _silent: {
            value: true // buffer for state switch, to restore previous state ad nauseum
        },
        search: {
            value:Y.myc.Search.Model.model()    //use a model to search and fire events
        },
        locals:{
            value: new Y.myc.Locals.Model()
        },
        // in order, the route handlers
        routes: {
            value:[
                { path: '*',             callback: __('filter')     },
                { path: '*',             callback: __('initialMap') },
                { path: '/directions/*', callback: __('directions') },
                { path: '/businesses/*', callback: __('businesses') },
                { path: '/place/*',      callback: __('place')      },
                { path: '/map/*',        callback: __('map')    },
                { path: '*',             callback: __('index')      }
            ]
        },
        initialLoad: {
            getter: function(){
                if (this.routingCount === 0) {
                    return true;
                }
                return false;
            }
        }
    };

    Y.extend(Router, Y.Router, {
        routingCount : 0,
        forceUpdate : false,
        initializer: function(){
            var t = this;
            t.host.on('state:change', this._onStateChange, this);
        },
        start: function() {
            var t = this,
               url = Y.getLocation().href,
               qo = url.split('?')[1] || url.split('#')[1];

            if (qo) {
                qo = Y.myc.util.queryStringParse(qo);
                if (qo.q) {
                    t.fire('found:q', {q:qo.q});
                }
                if (url.match(/\/place\//gi)) {
                    Y.log('Router :: Bookmark : Location');
                    t.fire('bookmark:location');
                    if (t.get('html5') && window.location.hash) t.forceUpdate=true;
                    t.searchPlace(qo,null,null,null);
                } else if (url.match(/\/businesses\//gi)) {
                    Y.log('Router :: Bookmark : Businesses');
                    t.fire('bookmark:businesses');
                    if (t.get('html5') && window.location.hash) t.forceUpdate=true;
                    t.searchBusinesses(qo,null,null,null);
                } else if (url.match(/\/directions\//gi)) {
                    Y.log('Router :: Bookmark : Directions');
                    t.fire('bookmark:directions');
                    if (t.get('html5') && window.location.hash) t.forceUpdate=true;
                    t.searchDirections(qo,null,null,null);
                } else if (url.match(/\/map\//gi)) {
                    Y.log('Router :: Bookmark : Map');
                    if (t.get('html5') && window.location.hash) t.forceUpdate=true;
                    t.fire('bookmark:map');
                    t.map();
                } else {
                    t.checkLegacy();
                }
            }
        },
        _onStateChange: function(e) {
            Y.log('Router : State Change');
            var state = e.state,
                active = state.active,
                params = {},
                wp_regex = /[wW]\d+$/,
                dp_regex = /[dD]\d+$/,
                url;

            Y.each(defaults, function(value, key) {
                Y.Lang.isValue(state[key]) && (params[key] = state[key]);
            });
            //patch for waypoints. MUST FIX.
            Y.each(state, function(value, key) {
                if (wp_regex.test(key)) {
                    params[key] = value;
                }
            });
            Y.each(state, function(value, key) {
                if (dp_regex.test(key)) {
                    params[key] = value;
                }
            });

            url = (active?('/' + active + '/'):'/map/') + '?' + Y.QueryString.stringify(params);
            if (e.save) {
                this.save(url, {silent:true});
            } else {
                this.replace(url, {silent:true});
            }
        },
        // extending a couple of base functions to accept options
        save: function(url, options){
            options = options || {};

            if (options.silent) {
                this.set('_silent', this.get('silent'));
                this.set('silent', true);
            }
            Router.superclass.save.apply(this, [url]);
        },
        replace: function(url, options){
            options = options || {};

            if (options.silent) {
                this.set('_silent', this.get('silent'));
                this.set('silent', true);
            }
            Router.superclass.replace.apply(this, [url]);
        },
        dispatch: function(options){
            options = options || {};
            var _silent = this.get('silent');
            if (options.silent) {
                this.set('_silent', this.get('silent'));
                this.set('silent', true);
            }
            Router.superclass.dispatch.apply(this);
        },
        // Check for legacy URLs
        checkLegacy: function(){
            var qo = Y.getLocation().href.split('#')[1],
                newHash = {};

            if (qo) {
                qo = Y.myc.util.queryStringParse(qo);
                if (qo.q2) {
                    if (this.get('initialLoad')) {
                        Y.myc.config.set('legacy',true);
                        this.fire('legacy',{type : 'directions'});
                    }
                    newHash.o = qo.q1 ? qo.q1 : '';
                    newHash.d = qo.q2;
                    if (qo.tl && qo.br) {
                        newHash.bb = qo.tl + ',' + qo.br;
                    }
                    if (qo.highways) {
                        newHash.fwy = qo.highways;
                    }
                    this.forceUpdate = true;
                    Y.log('Router :: Legacy : Directions');
                    this.searchDirections(newHash,null,null,null);
                    return true;
                } else if ((qo.tt || qo.business) && (qo.q || qo.q1 || qo.location)) {
                    if (this.get('initialLoad')) {
                        Y.myc.config.set('legacy',true);
                        this.fire('legacy',{type : 'businesses'});
                    }
                    newHash.bid = qo.bid;
                    newHash.n = qo.q || qo.q1 || qo.location;
                    newHash.b = qo.tt || qo.business;
                    if (qo.start) {
                        newHash.p = parseInt(qo.start / (Y.myc.config('pagination.limit') || 10), 10) + 1;
                    }
                    if (parseInt(qo.conf, 10) === 0) {
                        newHash.conf = 0;
                    }
                    this.forceUpdate = true;
                    Y.log('Router :: Legacy : Business');
                    this.searchBusinesses(newHash,null,null,null);
                    return true;
                } else if (qo.q || qo.q1 || qo.location) {
                    if (this.get('initialLoad')) {
                        Y.myc.config.set('legacy',true);
                        this.fire('legacy',{type : 'place'});
                    }
                    newHash.addr = qo.q || qo.q1 || qo.location;
                    Y.log('Router :: Legacy : Place');
                    this.forceUpdate = true;
                    this.searchPlace(newHash,null,null,null);
                    return true;
                } else {
                   this.forceUpdate = true;
                    if (this.get('initialLoad')) {
                        Y.myc.config.set('legacy',true);
                        this.fire('legacy',{type : 'onlyMap'});
                    }
                    this.map();
                    return true;
                }
            }
            return false;
        },
        filter: function(req, res, next){
            if (this.forceUpdate === true) {
                this.forceUpdate = false;
                this.set('silent',false);
                return;
            }
            var qo = req.query || {},
                q = qo.q;
            this.routingCount++;
            Y.log('Router :: Routing Count : '+this.routingCount);
            if (this.get('silent')) {
                this.set('silent', this.get('_silent'));
                return;
            } else {
                this.routing = true;
            }
            if (!this.get('html5_hash')) {
                this.fire('router:start');
            }
            this.set('html5_hash',false);
            next();
            if (q) {
                this.fire('found:q', {q:q});
            }
        },
        // find
        getBB: function(req){
            var bb = (req.query || req || {}).bb;
            if (!bb) return null; //todo - use config/default for this
            bb = Y.Array.map(bb.split(','), function(l){ return parseFloat(l, 10);});
            return ({
                tl: new Y.YMaps.GeoLocation({
                    lat: bb[0],
                    lon: bb[1]
                }),
                br: new Y.YMaps.GeoLocation({
                    lat: bb[2],
                    lon: bb[3]
                })
            });
        },
        getCenter: function(req){
            var bb = this.getBB(req),
                lat,
                lon;
            if (bb) {
                lat = (bb.tl.get('lat') + bb.br.get('lat'))/2;
                lon = (bb.tl.get('lon') + bb.br.get('lon'))/2;
            } else {
                lat = parseFloat(Y.myc.config('ymaps.center.latitude'),10);
                lon = parseFloat(Y.myc.config('ymaps.center.longitude'),10);
            }
            return (new Y.YMaps.GeoLocation({lat: lat, lon: lon}));

        },
        // common point of failing for a url with intent. helper.
        _fail: function(req, res, next){
            var t = this,
                qo = (req && req.query)||{},
                q = qo.q;

            this.fire('fail');
            this.fire('end');
            return;
        },
        setupMap: function(qo, req, res, next){
            next = (next || function(){});
            var typeMap = {
                    'm' : '0',
                    'h' : '1',
                    's' : '3'
                },
                _t = this,
                bb = _t.getBB(req),
                t = qo.t,
                trf = qo.trf === 1 ? true: false,
                lat = qo.lat,
                lon = qo.lon,
                zoomLevel = qo.zoom,
                queryParamsFound = false,
                e = {};

            if (bb) {
                e.bb = bb;
                _t.routing = true;
            } else if (lat && lon && zoomLevel) {
                e.lat = lat;
                e.lon = lon;
                e.zoomLevel = zoomLevel;
                _t.routing = true;
            } else {
                _t.routing = false;
            }
            if (t) {e.t = t;}
            if (trf) {e.trf = trf;}
            for (var qp in qo){
                if (qo.hasOwnProperty(qp)) {
                    queryParamsFound = true;
                }
            }
            _t.fire('found:map', e);
            next();
        },
        initialMap: function(req, res, next){
            this.setupMap(req.query,req,res,next);
        },
        searchDirections:function(qo, req, res, next){
            next = (next || function(){});
            var t = this,
                source = qo.o || qo.addr || qo.oll,
                dest = qo.d || qo.daddr || qo.dll,
                flags = qo.dt || '',
                waypoints = [],
                dragpoints = {},
                wp_regex = /[wW]\d+$/,
                dp_regex = /[dD]\d+$/;

            Y.each(qo, function(value, key){
                if (wp_regex.test(key)) {
                    waypoints.push(value);
                }
            });
            Y.each(qo, function(value, key){
                if(dp_regex.test(key)){
                    dragpoints[key]=value;
                }
            });
            if (!source && !dest) {
                // if both source and destination don't exist
                // silently fail with an event and move on to index
                t.routing = false;
                Y.log('bad directions url, moving on');
                t._fail(req, res, next);
                return;
            }

            if (t.get('silent')) {
                // silent setting of url
                t.fire('silent:directions');
                t.fire('end');
                return;
            }
            t.fire('found:directions:init',{
                type : t.routingCount !== 0 ? 'Navigation' : 'Bookmark'
            });
            t.fire('found:directions',{
                locations: [source].concat(waypoints, [dest]), //whatever locations you get
                units: qo.units,
                freeways:(qo.fwy + '') === '1'? true: false,
                tolls: (qo.tolls + '') === '1'? true: false,
                dragpoints : dragpoints
            });
        },
        directions:function(req, res, next){
            this.searchDirections(req.query,req,res,next);
        },
        searchBusinesses:function(qo, req, res, next){
            next = (next || function(){});
            var t = this,
                near = qo.n || qo.naddr,
                nearId = qo.nid,
                llr = qo.nllr || null,
                hname = qo.hn,
                smarker = qo.sm,
                bizTitle = qo.bt,
                bizId = qo.bid,
                b = qo.b,
                p = parseInt(qo.p,10) || Y.myc.config('businesses.pageNumber'),
                s = (p-1) * Y.myc.config('pagination.limit') + 1;

            if (!(near || llr) || !b) {
                // silently fail with an event and move on to index
                Y.log('missing businesses params, moving on');
                this._fail(req, res, next);
                return;
            }
            if (this.get('silent')) {
                // silent setting of url
                this.fire('silent:businesses');
                this.fire('end');
                return;
            }
            t.fire('found:businesses:init',{
                type : t.routingCount !== 0 ? 'Navigation' : 'Bookmark'
            });
            var businesses, local, locations, llrArr = null;
            Y.parallel(function(callback){
                var options = {
                    stx: b,
                    begin: s || 1,
                    details : {
                    }
                };
                if (bizId) {
                    options.id = bizId;
                } else if (llr) {
                    llrArr = Y.Array.map(llr.split(','), function(l){ return parseFloat(l, 10);});
                    options.lat = llrArr[0];
                    options.lon = llrArr[1];
                    options.radius = llrArr[2];
                } else {
                    options.csz = near;
                }
                t.get('locals').query(
                    options,
                    function(err, data){
                    if (err) {
                        t._fail(req, res, next);
                        return;
                    } else if (!err) {
                        businesses = data.local.businesses;
                        local = data.local;
                    }
                    callback && callback();
                });
            },function(callback){
                if (near) {
                    // Instead of using one box for the location in case of business search using the find location and the locals
                    if (bizTitle || nearId) {
                        var opts = {};
                        if (nearId){
                            opts.id = nearId;
                        } else {
                            opts.stx = bizTitle;
                            opts.csz = near;
                        }
                        t.get('locals').query(opts, function(err, data){
                            if(!err){
                                if (data.local && data.local.businesses && data.local.businesses[0]){
                                    locations = data.local.businesses;
                                }
                            }
                            callback && callback();
                        });
                    } else {
                        t.get('search').findLocation({q : near}, function(err, data){
                            if(!err){
                                if (data.locations){
                                    locations = data.locations;
                                }
                            }
                            callback && callback();
                        });
                    }
                    // t.get('search').query((bizTitle)? bizTitle + ' near ' + near: near, function(err, data){
                    //     if(!err){
                    //         if (bizTitle && data.local && data.local.businesses && data.local.businesses[0]){
                    //             locations = data.local.businesses;
                    //         } else {
                    //             locations = data.locations;
                    //         }
                    //     }
                    //     callback && callback();
                    // });
                } else {
                    callback && callback();
                }
            }).then(function(){
                var bo = {};
                bo.businesses = businesses;
                bo.local = local;
                bo.locations = locations;
                bo.queryBusiness = b;
                bo.p = p;
                bo.llr = llrArr;
                bo.hname = hname;
                bo.smarker = smarker;
                bo.bizMap = (bizId)? true : false;
                if (Y.Lang.isValue(qo.conf)) {
                    bo.conf = (qo.conf === 0) ? false : true;
                } else {
                    bo.conf = Y.myc.config('businesses.hiConf');
                }
                if (!bo.hname) {
                    bo.local.details.locationsource = 'explicit';
                    bo.local.details.location = near;
                }
                t.fire('found:businesses',bo);
                t.fire('end');
            });
        },
        businesses:function(req, res, next){
            this.searchBusinesses(req.query,req,res,next);
        },
        searchPlace: function(qo,req,res,next) {
            next = (next || function(){});
            var t = this,
                place = qo.addr || qo.ll;

            if (!place) {
                // silently fail with an event and move on to index
                Y.log('bad place url, moving on');
                t._fail(req, res, next);
                return;
            }
            t.fire('found:place:init',{
                type : t.routingCount !== 0 ? 'Navigation' : 'Bookmark'
            });
            t.get('search').findLocation({
                q : place
            }, function(err, data){
                if (err) {
                    t._fail(req, res, next);
                    return;
                }
                t.fire('found:place',{
                    location : data.locations[0],
                    q : qo.q || qo.addr
                });
                t.fire('end');
            });
        },
        place: function(req, res, next){
            this.searchPlace(req.query,req,res,next);
        },
        map: function(req, res, next){
            this.fire('found:simpleMap',{
                type : this.routingCount !== 0 ? 'Navigation' : 'Bookmark'
            });
            this.fire('end');
        },
        index:function(req, res, next){
            if (!this.checkLegacy()) {
                this.fire('found:nothing',{
                    type : this.routingCount !== 0 ? 'Navigation' : 'Bookmark'
                });
            }
            this.fire('end');
        },
        clear: function(){
            Y.log('Router : Clear Called');
            this.routing = false;
        }
    },{
        current: function(){
            return Y.getLocation().href.replace('#/','');
        }
    });

    Y.namespace('myc.App');
    Y.myc.App.Router = Router;

},'@VERSION@',{
    requires:[
        'querystring',
        'querystring-parse',
        'router',
        'myc-deferred',
        'myc-search-model',
        'myc-location-model',
        'myc-locals',
        'myc-utils',
        'myc-config',
        'node-event-html5'
    ]
});